// Copyright (c) 2013 Willink Transformations, University of Yok and others.
// All rights reserved. This program and the accompanying materials
// are made available under the terms of the Eclipse Public License v1.0
// which accompanies this distribution, and is available at
// http://www.eclipse.org/legal/epl-v10.html
// 
// Contributors:
// 		Adolfo Sanchez-Barbudo Herrera (Univerisity of York) - Initial API and implementation

modeltype ECORE "strict" uses ecore('http://www.eclipse.org/emf/2002/Ecore');

transformation VisitorPatternTransf(inout packages : ECORE, in baseVisitorPackage : ECORE);

configuration property baseVisitorInterfaceName : String;
configuration property derivedVisitorInterfaceName : String;
configuration property derivedVisitorInterfaceQualifiedName : String;

main() 
{
	var baseVisitorClass := baseVisitorPackage.rootObjects()![EPackage].findVisitorClass(baseVisitorInterfaceName);
	var targetPackage := packages.rootObjects()[EPackage];

	targetPackage->forEach(package) {
		package.map addVisitorInterface(derivedVisitorInterfaceName,
			derivedVisitorInterfaceQualifiedName,
			baseVisitorClass);
		var derivedVisitorClass := package.findVisitorClass(derivedVisitorInterfaceName);
		package.eClassifiers[EClass]->map addAcceptMethods(derivedVisitorClass);
	}
	
}

helper EPackage::findVisitorClass(in visitorName : String) : EClass 
{
	return self	->closure(self.eSubpackages)
				->including(self)
				->collectOne(
		self.eClassifiers![oclIsKindOf(EClass) and name = visitorName].oclAsType(EClass))
}

helper createAcceptMethod(in visitorClass : EClass) : EOperation {
	
	return object EOperation {
		name := 'accept';
		var typeParameter = object ETypeParameter {
			name := visitorClass.eTypeParameters->first().name;
		};
		eTypeParameters += typeParameter;
		eGenericType := object EGenericType {
			eTypeParameter := typeParameter;
		};
		
		eParameters += object EParameter {
			name := "v";
			eGenericType := object EGenericType {
				eClassifier := visitorClass;  // Derived Visitor Class ?
				eTypeArguments := object EGenericType {
					eTypeParameter := typeParameter;
				}
			}
		}
	};
}

mapping inout EPackage::addVisitorInterface(in visitorName : String, 
		in visitorInstanceClassName : String, 
		in baseVisitorClass : EClass) 
	when { self.eClassifiers->select(name = visitorName)->isEmpty(); }
{
	var visitor:= object EClass {
		name := visitorName;
		instanceClassName := visitorInstanceClassName;
		_abstract := true;
		interface := true;				
	};
	
	if (not baseVisitorClass.oclIsUndefined()) then {
		if (baseVisitorClass.eTypeParameters->isEmpty()) then {
			visitor.eSuperTypes += baseVisitorClass;
		} else {
			var typeParameter := object EGenericType {
				eClassifier := baseVisitorClass;
			};
			visitor.eGenericSuperTypes += typeParameter; 
			baseVisitorClass.eTypeParameters->forEach(x) {
				var argument := x.clone().oclAsType(ETypeParameter);
				visitor.eTypeParameters += argument;
				typeParameter.eTypeArguments += object EGenericType {
					eTypeParameter := argument;
				}; 
			};
		} endif;
	} endif;
	
	eClassifiers += visitor; 
}

mapping inout EClass::addAcceptMethods(in derivedVisitorClass: EClass) 
	when { self.eOperations->select(name = 'accept')->isEmpty()
			and not self._abstract  
			and not self.interface; } 
{
	var acceptOp := createAcceptMethod(derivedVisitorClass);
	acceptOp.eAnnotations += object EAnnotation {
		source := "http://www.eclipse.org/emf/2002/GenModel";
		details += object EStringToStringMapEntry {
			key := "body";
			value := "return v.visit" + self.name + "(this);";
		}	
	};
			
//	acceptOp.eAnnotations += object EAnnotation {
//		source := "http://www.eclipse.org/emf/2002/GenModel";
//		details += object EStringToStringMapEntry {
//			key := "body";
//			value := "return ((" + derivedVisitorClass.name + "<R>)v).visit" + self.name + "(this);";
//		}	
//	};
	
	eOperations += acceptOp;	
}