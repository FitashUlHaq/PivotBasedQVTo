modeltype UML uses uml('http://www.eclipse.org/uml2/2.1.0/UML');
modeltype SPEM uses spem('http://org.eclipse.m2m.qvt.oml/examples/omg/SPEM');
 
transformation SpemProfile2Metamodel(in umlmodel:UML,out spemmodel:SPEM);

query UML::Element::isStereotypedBy(stereotypeName:String) : Boolean {
	return false;
}
query UML::Classifier::getOppositeAends() : Set(UML::Property) {
	return null;
}

main () {
	-- first pass: create all the SPEM elements from UML elements
	umlmodel.rootObjects()[UML::Model]->map createDefaultPackage();
	-- second pass: add the dependencies beyween SPEM elements
	umlmodel.objects()[UML::UseCase]->map addDependenciesInWorkDefinition();
}

mapping UML::Package::createDefaultPackage () : SPEM::Package {
	name := self.name;
	ownedElement := self.ownedElement->map createModelElement()->asSequence();
}

mapping UML::Package::createProcessComponent () : SPEM::ProcessComponent
	inherits UML::Package::createDefaultPackage
when {self.isStereotypedBy('ProcessComponent')}
{}

mapping UML::Package::createDiscipline () : SPEM::Discipline
	inherits UML::Package::createDefaultPackage
	when {self.isStereotypedBy('Discipline')}
{}

mapping UML::/*Model*/Element::createModelElement () : SPEM::ModelElement
disjuncts
	UML::Actor::createProcessRole, UML::UseCase::createWorkDefinition,
	UML::Package::createProcessComponent, UML::Package::createDiscipline
{}

mapping UML::UseCase::createWorkDefinition() : SPEM::WorkDefinition
disjuncts
	UML::UseCase::createLifeCycle, UML::UseCase::createPhase, UML::UseCase::createIteration,
	UML::UseCase::createActivity, UML::UseCase::createCompositeWorkDefinition
{}

mapping UML::Actor::createProcessRole () : SPEM::ProcessRole
when {self.isStereotypedBy('ProcessRole')}
{}

-- rule to create the default process performer singleton
mapping createOrRetrieveDefaultPerformer () : SPEM::ProcessPerformer {
	init {
		result := resolveoneIn(createOrRetrieveDefaultPerformer, SPEM::ProcessPerformer);
		-- In OMG spec : if result then return null endif;
		-- -> not needed, it's a singleton by the execution semantics
	}
	name := 'ProcessPerformer';
}

abstract mapping UML::UseCase::createCommonWorkDefinition () : SPEM::WorkDefinition
{
	name := self.name;
	-- QVTO : to be replaced by a composite assignment
	--constraint += self.constraint[isStereotypedBy('precondition')]->map createPrecondition();
	--constraint += self.constraint[isStereotypedBy('goal')]->map createGoal();
	constraint += self.ownedRule[isStereotypedBy('precondition')]->map createPrecondition();
	constraint += self.ownedRule[isStereotypedBy('goal')]->map createGoal();	
}

mapping UML::UseCase::createActivity () : SPEM::WorkDefinition
	inherits UML::UseCase::createCommonWorkDefinition
	when {self.isStereotypedBy('Activity')}
{}

mapping UML::UseCase::createPhase () : SPEM::Phase
	inherits UML::UseCase::createCommonWorkDefinition
	when {self.isStereotypedBy('Phase')}
{}

mapping UML::UseCase::createIteration () : SPEM::Iteration
inherits UML::UseCase::createCommonWorkDefinition
when {self.isStereotypedBy('Iteration')}
{}

mapping UML::UseCase::createLifeCycle () : SPEM::Lifecycle 
	inherits UML::UseCase::createCommonWorkDefinition
	when {self.isStereotypedBy('LifeCycle')}
{}

mapping UML::UseCase::createCompositeWorkDefinition () : SPEM::WorkDefinition
	inherits UML::UseCase::createCommonWorkDefinition
	when {self.isStereotypedBy('WorkDefinition')}
{}

mapping UML::Constraint::createPrecondition () : SPEM::Precondition {
	body := self.specification![OpaqueExpression].body->asSequence()->first();
}

mapping UML::Constraint::createGoal () : SPEM::Goal {
	body := self.specification![OpaqueExpression].body->asSequence()->first();
}

mapping UML::UseCase::addDependenciesInWorkDefinition () 
	: SPEM::WorkDefinition merges UML::UseCase::addDependenciesInActivity {
	init {
		result := self.resolveone(WorkDefinition);
		var performers := self.getOppositeAends()
			[/*i|i.*/association[isStereotypedBy('perform')]->notEmpty()];
		assert (not (performers->size()>1)) with log('A unique performer is allowed', self);
	}
	subWork += self.clientDependency[isStereotypedBy('includes')].supplier.resolveone(WorkDefinition);
	performer := if performers->notEmpty() 
					then performers->asSequence()->first().getOtherEnd().resolveone(ProcessRole)
					else map createOrRetrieveDefaultPerformer() endif;
}

mapping UML::UseCase::addDependenciesInActivity () : SPEM::WorkDefinition
	when {self.isStereotypedBy('Activity')}
{
	init {
		var activity := result.oclAsType(SPEM::Activity);
		if(not activity.oclIsUndefined()) then {
			object activity : SPEM::Activity {
				assistant := self.getOppositeAends()[/*i|i.*/association
					[/*a|a.*/isStereotypedBy('assist')]->notEmpty()]/*->*/.resolve(ProcessRole);				
			}
		} endif;
	}	
}